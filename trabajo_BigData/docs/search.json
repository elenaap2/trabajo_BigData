[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Análisis general del speedrunning: Super Mario 64",
    "section": "",
    "text": "Hola, soy Elena Paredes Borrachero.\nEsta web sirve para presentar el trabajo final individual para la asignatura “Programación y manejo de datos en la era Del Big Data”, optativa de GECO en la Facultad de Economía de la Universitat de València.\nLa web de la asignatura está aquí y los trabajos de mis compañeros de curso puedes verlos aquí.\nMi trabajo lleva por título: “Análisis general del speedrunning: Super Mario 64”. El objetivo es realizar un recorrido general dentro de la temática de los videojuegos sobre el mundo del speedrunning, acotándolo a uno de sus juegos más populares: Super Mario 64, estrenado en el año 1996.\nEl trabajo puede verse aquí."
  },
  {
    "objectID": "my_trabajo_BigData.html",
    "href": "my_trabajo_BigData.html",
    "title": "Análisis general del speedrunning: Super Mario 64",
    "section": "",
    "text": "El objetivo del presente trabajo es hacer un recorrido general dentro de la temática de los videojuegos sobre el mundo del speedrunning. Se realizará un breve análisis sobre los videojuegos más habituales con más speedruns, la evolución de los récords y cómo los jugadores ingenian nuevas formas de reducir su tiempo. Además, para poder acotar el análisis, estará centrado en uno de los videojuegos más populares: Super Mario 64, estrenado en el año 1996.\nLos datos utilizados han sido extraídos previamente de la página web de Kaggle y de Speedrun.com siendo reordenados y adaptados para realizar el trabajo. Estos datos han sido importados en la memoria de R/RStudio en formato .csv y .xlsx. En el último apartado, se incluyen las referencias utilizadas con sus respectivas URLs.\n\n\n\n\nCódigo\n#- Parquetes usados\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(plotly)\nlibrary(gt)\nlibrary(ggThemeAssist)\nlibrary(gtExtras)\nlibrary(sf)\nlibrary(maps)\nlibrary(tmap)\nlibrary(readxl)\nlibrary(dplyr)\nlibrary(viridis)\nlibrary(stringr)\n\n#- Carga de datos\nspeed_cat &lt;- read.csv(\"./data/category_data.csv\")\nspeed_games &lt;- read.csv(\"./data/game_data.csv\")\nmario_16 &lt;- read.csv(\"./data/data_16_star.csv\")\nop_TAS &lt;- read.csv(\"./data/f_dataset.csv\")\nnum_runs &lt;- readxl::read_xlsx(\"./data/top_runs.xlsx\")\nmario_record &lt;- read.csv(\"./data/history_mario.csv\")"
  },
  {
    "objectID": "my_trabajo_BigData.html#intro",
    "href": "my_trabajo_BigData.html#intro",
    "title": "Los pingüinos molan",
    "section": "",
    "text": "Vamos a utilizar datos del paquete palmerpenguins. El repo del paquete en CRAN está aquí, el repo de Github está aquí y la página web del paquete está aquí.\nLos datos se pueden cargar en la memoria de de R/RStudio de esta forma:\n\nCódigo# install.packages(\"palmerpenguins\")\nlibrary(palmerpenguins)\ndf &lt;- palmerpenguins::penguins\n\n\nEl dataset contiene observaciones sobre un conjunto de 344 pingüinos de 3 especies. Hay 8 variables."
  },
  {
    "objectID": "my_trabajo_BigData.html#los-pingüinos-molan",
    "href": "my_trabajo_BigData.html#los-pingüinos-molan",
    "title": "Videojueguitos rapiditos",
    "section": "Los pingüinos molan",
    "text": "Los pingüinos molan\nVamos a ver una foto de un pingüinos\n\n\n\nUn pingüino chulo\n\n\n\nSí, lo pingüinos molan, así que vamos a poner otra foto de pingüinos que tenemos en nuestro PC pero la vamos a poner en el margen:"
  },
  {
    "objectID": "my_trabajo_BigData.html#algunos-gráficos",
    "href": "my_trabajo_BigData.html#algunos-gráficos",
    "title": "Videojueguitos rapiditos",
    "section": "Algunos gráficos",
    "text": "Algunos gráficos\nBueno pues vamos a hacer algún gráfico, pero claro antes he de cargar los paquetes\n\n\nCódigo\nlibrary(tidyverse)\n\n\nArreglo los datos\n\n\nCódigo\n#- cojos datos de pingüinos y arreglo un poco \ndf &lt;- palmerpenguins::penguins %&gt;% \n  dplyr::select(species, bill_depth_mm, body_mass_g) %&gt;% \n  tidyr::drop_na()\n\n\n\n\nPrimer gráfico\n\n\nCódigo\n#- primer gráfico\np &lt;- ggplot(data = df, \n       mapping = aes(x = bill_depth_mm, y = body_mass_g, color = species)) +\n     geom_point()\np\n\n\n\n\n\n\n\n\n\n\n\n\nSegundo\n\n\nCódigo\n#- segundo gráfico\np &lt;- p + geom_smooth(method = \"lm\", se = FALSE) \n\np\n\n\n\n\n\n\n\n\n\n\n\n\nEl último\n\n\nCódigo\n#- tercer gráfico\np + geom_smooth(method = \"lm\", se = FALSE, color = \"black\") \n\n\n\n\n\n\n\n\n\n\nCon esto acabo mi trabajo para BigData!!\n\n\n\n\n\nInformación sobre la sesión\nAbajo muestro mi entorno de trabajo y paquetes utilizados.\n\n\n\n\n current session info \n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16 ucrt)\n os       Windows 11 x64 (build 22631)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  Spanish_Spain.utf8\n ctype    Spanish_Spain.utf8\n tz       Europe/Madrid\n date     2024-01-24\n pandoc   3.1.1 @ D:/Programming_2023/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package        * version   date (UTC) lib source\n abind            1.4-5     2016-07-21 [1] CRAN (R 4.3.1)\n base64enc        0.1-3     2015-07-28 [1] CRAN (R 4.3.0)\n cellranger       1.1.0     2016-07-27 [1] CRAN (R 4.3.1)\n class            7.3-22    2023-05-03 [1] CRAN (R 4.3.1)\n classInt         0.4-10    2023-09-05 [1] CRAN (R 4.3.1)\n cli              3.6.1     2023-03-23 [1] CRAN (R 4.3.1)\n clipr            0.8.0     2022-02-22 [1] CRAN (R 4.3.1)\n codetools        0.2-19    2023-02-01 [1] CRAN (R 4.3.1)\n colorspace       2.1-0     2023-01-23 [1] CRAN (R 4.3.1)\n crosstalk        1.2.0     2021-11-04 [1] CRAN (R 4.3.1)\n data.table       1.14.8    2023-02-17 [1] CRAN (R 4.3.1)\n DBI              1.1.3     2022-06-18 [1] CRAN (R 4.3.1)\n desc             1.4.3     2023-12-10 [1] CRAN (R 4.3.2)\n details          0.3.0     2022-03-27 [1] CRAN (R 4.3.2)\n dichromat        2.0-0.1   2022-05-02 [1] CRAN (R 4.3.1)\n digest           0.6.33    2023-07-07 [1] CRAN (R 4.3.1)\n dplyr          * 1.1.3     2023-09-03 [1] CRAN (R 4.3.1)\n e1071            1.7-13    2023-02-01 [1] CRAN (R 4.3.1)\n ellipsis         0.3.2     2021-04-29 [1] CRAN (R 4.3.1)\n evaluate         0.21      2023-05-05 [1] CRAN (R 4.3.1)\n fansi            1.0.4     2023-01-22 [1] CRAN (R 4.3.1)\n farver           2.1.1     2022-07-06 [1] CRAN (R 4.3.1)\n fastmap          1.1.1     2023-02-24 [1] CRAN (R 4.3.1)\n forcats        * 1.0.0     2023-01-29 [1] CRAN (R 4.3.1)\n formatR          1.14      2023-01-17 [1] CRAN (R 4.3.1)\n generics         0.1.3     2022-07-05 [1] CRAN (R 4.3.1)\n ggplot2        * 3.4.3     2023-08-14 [1] CRAN (R 4.3.1)\n ggThemeAssist  * 0.1.5     2016-08-13 [1] CRAN (R 4.3.1)\n glue             1.6.2     2022-02-24 [1] CRAN (R 4.3.1)\n gt             * 0.9.0     2023-03-31 [1] CRAN (R 4.3.1)\n gtable           0.3.4     2023-08-21 [1] CRAN (R 4.3.1)\n hms              1.1.3     2023-03-21 [1] CRAN (R 4.3.1)\n htmltools        0.5.6     2023-08-10 [1] CRAN (R 4.3.1)\n htmlwidgets      1.6.2     2023-03-17 [1] CRAN (R 4.3.1)\n httpuv           1.6.11    2023-05-11 [1] CRAN (R 4.3.1)\n httr             1.4.7     2023-08-15 [1] CRAN (R 4.3.1)\n jsonlite         1.8.7     2023-06-29 [1] CRAN (R 4.3.1)\n KernSmooth       2.23-21   2023-05-03 [1] CRAN (R 4.3.1)\n knitr            1.44      2023-09-11 [1] CRAN (R 4.3.1)\n labeling         0.4.3     2023-08-29 [1] CRAN (R 4.3.1)\n later            1.3.1     2023-05-02 [1] CRAN (R 4.3.1)\n lattice          0.21-8    2023-04-05 [1] CRAN (R 4.3.1)\n lazyeval         0.2.2     2019-03-15 [1] CRAN (R 4.3.1)\n leafem           0.2.3     2023-09-17 [1] CRAN (R 4.3.2)\n leaflet          2.2.1     2023-11-13 [1] CRAN (R 4.3.2)\n leafsync         0.1.0     2019-03-05 [1] CRAN (R 4.3.2)\n lifecycle        1.0.3     2022-10-07 [1] CRAN (R 4.3.1)\n lubridate      * 1.9.2     2023-02-10 [1] CRAN (R 4.3.1)\n lwgeom           0.2-13    2023-05-22 [1] CRAN (R 4.3.2)\n magrittr         2.0.3     2022-03-30 [1] CRAN (R 4.3.1)\n maps           * 3.4.1.1   2023-11-03 [1] CRAN (R 4.3.2)\n Matrix           1.6-1.1   2023-09-18 [1] CRAN (R 4.3.1)\n mgcv             1.8-42    2023-03-02 [1] CRAN (R 4.3.1)\n mime             0.12      2021-09-28 [1] CRAN (R 4.3.0)\n miniUI           0.1.1.1   2018-05-18 [1] CRAN (R 4.3.1)\n munsell          0.5.0     2018-06-12 [1] CRAN (R 4.3.1)\n nlme             3.1-162   2023-01-31 [1] CRAN (R 4.3.1)\n palmerpenguins   0.1.1     2022-08-15 [1] CRAN (R 4.3.1)\n pillar           1.9.0     2023-03-22 [1] CRAN (R 4.3.1)\n pkgconfig        2.0.3     2019-09-22 [1] CRAN (R 4.3.1)\n plotly         * 4.10.2    2023-06-03 [1] CRAN (R 4.3.1)\n png              0.1-8     2022-11-29 [1] CRAN (R 4.3.0)\n promises         1.2.1     2023-08-10 [1] CRAN (R 4.3.1)\n proxy            0.4-27    2022-06-09 [1] CRAN (R 4.3.1)\n purrr          * 1.0.2     2023-08-10 [1] CRAN (R 4.3.1)\n R6               2.5.1     2021-08-19 [1] CRAN (R 4.3.1)\n raster           3.6-26    2023-10-14 [1] CRAN (R 4.3.2)\n RColorBrewer     1.1-3     2022-04-03 [1] CRAN (R 4.3.0)\n Rcpp             1.0.11    2023-07-06 [1] CRAN (R 4.3.1)\n readr          * 2.1.4     2023-02-10 [1] CRAN (R 4.3.1)\n readxl           1.4.3     2023-07-06 [1] CRAN (R 4.3.1)\n rlang            1.1.1     2023-04-28 [1] CRAN (R 4.3.1)\n rmarkdown        2.25      2023-09-18 [1] CRAN (R 4.3.1)\n rstudioapi       0.15.0    2023-07-07 [1] CRAN (R 4.3.1)\n scales           1.2.1     2022-08-20 [1] CRAN (R 4.3.1)\n sessioninfo      1.2.2     2021-12-06 [1] CRAN (R 4.3.2)\n sf             * 1.0-14    2023-07-11 [1] CRAN (R 4.3.2)\n shiny            1.7.5     2023-08-12 [1] CRAN (R 4.3.1)\n sp               2.1-1     2023-10-16 [1] CRAN (R 4.3.2)\n stars            0.6-4     2023-09-11 [1] CRAN (R 4.3.2)\n stringi          1.7.12    2023-01-11 [1] CRAN (R 4.3.0)\n stringr        * 1.5.0     2022-12-02 [1] CRAN (R 4.3.1)\n terra            1.7-55    2023-10-13 [1] CRAN (R 4.3.2)\n tibble         * 3.2.1     2023-03-20 [1] CRAN (R 4.3.1)\n tidyr          * 1.3.0     2023-01-24 [1] CRAN (R 4.3.1)\n tidyselect       1.2.0     2022-10-10 [1] CRAN (R 4.3.1)\n tidyverse      * 2.0.0     2023-02-22 [1] CRAN (R 4.3.1)\n timechange       0.2.0     2023-01-11 [1] CRAN (R 4.3.1)\n tmap           * 3.3-4     2023-09-12 [1] CRAN (R 4.3.2)\n tmaptools        3.1-1     2021-01-19 [1] CRAN (R 4.3.2)\n tzdb             0.4.0     2023-05-12 [1] CRAN (R 4.3.1)\n units            0.8-4     2023-09-13 [1] CRAN (R 4.3.2)\n utf8             1.2.3     2023-01-31 [1] CRAN (R 4.3.1)\n vctrs            0.6.3     2023-06-14 [1] CRAN (R 4.3.1)\n viridisLite      0.4.2     2023-05-02 [1] CRAN (R 4.3.1)\n withr            2.5.0     2022-03-03 [1] CRAN (R 4.3.1)\n xfun             0.40      2023-08-09 [1] CRAN (R 4.3.1)\n XML              3.99-0.16 2023-11-29 [1] CRAN (R 4.3.2)\n xml2             1.3.5     2023-07-06 [1] CRAN (R 4.3.1)\n xtable           1.8-4     2019-04-21 [1] CRAN (R 4.3.1)\n yaml             2.3.7     2023-01-23 [1] CRAN (R 4.3.0)\n\n [1] D:/Programming_2023/R-4.3.1/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "my_trabajo_BigData.html#introducción",
    "href": "my_trabajo_BigData.html#introducción",
    "title": "Análisis general del speedrunning: Super Mario 64",
    "section": "",
    "text": "El objetivo del presente trabajo es hacer un recorrido general dentro de la temática de los videojuegos sobre el mundo del speedrunning. Se realizará un breve análisis sobre los videojuegos más habituales con más speedruns, la evolución de los récords y cómo los jugadores ingenian nuevas formas de reducir su tiempo. Además, para poder acotar el análisis, estará centrado en uno de los videojuegos más populares: Super Mario 64, estrenado en el año 1996.\nLos datos utilizados han sido extraídos previamente de la página web de Kaggle y de Speedrun.com siendo reordenados y adaptados para realizar el trabajo. Estos datos han sido importados en la memoria de R/RStudio en formato .csv y .xlsx. En el último apartado, se incluyen las referencias utilizadas con sus respectivas URLs.\n\n\n\n\nCódigo\n#- Parquetes usados\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(plotly)\nlibrary(gt)\nlibrary(ggThemeAssist)\nlibrary(gtExtras)\nlibrary(sf)\nlibrary(maps)\nlibrary(tmap)\nlibrary(readxl)\nlibrary(dplyr)\nlibrary(viridis)\nlibrary(stringr)\n\n#- Carga de datos\nspeed_cat &lt;- read.csv(\"./data/category_data.csv\")\nspeed_games &lt;- read.csv(\"./data/game_data.csv\")\nmario_16 &lt;- read.csv(\"./data/data_16_star.csv\")\nop_TAS &lt;- read.csv(\"./data/f_dataset.csv\")\nnum_runs &lt;- readxl::read_xlsx(\"./data/top_runs.xlsx\")\nmario_record &lt;- read.csv(\"./data/history_mario.csv\")"
  },
  {
    "objectID": "my_trabajo_BigData.html#qué-es-una-speedrun",
    "href": "my_trabajo_BigData.html#qué-es-una-speedrun",
    "title": "Videojueguitos rapiditos",
    "section": "1.- ¿Qué es una Speedrun?",
    "text": "1.- ¿Qué es una Speedrun?\nVamos a ver una foto de un pingüinos\n\n\n\nUn pingüino chulo\n\n\n\nSí, lo pingüinos molan, así que vamos a poner otra foto de pingüinos que tenemos en nuestro PC pero la vamos a poner en el margen:"
  },
  {
    "objectID": "my_trabajo_BigData.html#sobre-el-speedrunning",
    "href": "my_trabajo_BigData.html#sobre-el-speedrunning",
    "title": "Análisis general del speedrunning: Super Mario 64",
    "section": "1. Sobre el speedrunning",
    "text": "1. Sobre el speedrunning\nA grandes rasgos, el speedrunning es cuando un jugador completa un videojuego lo más rápido posible de manera competitiva.\nEl objetivo es bajar lo máximo el contador de tiempo, y esto se logra a medida que practican, planifican y descubren o innovan nuevas maneras para hacerlo. Esto refiere a que usan a su favor bugs1 o glitches2 que existen en el código o la programación. Puede requerir de una gran habilidad, ya que los videojuegos están diseñados para que se jueguen de la manera que los programadores han determinado, y jugarlo de otra diferente requiere que el jugador “luche” contra el juego.\nLos jugadores dedican una gran cantidad de tiempo a perfeccionar sus runs y mejorar su habilidad, ya que existe la faceta competitiva de conseguir un WR (World Record).\nPor tanto, una run o speedrun, es el tiempo comprendido que pasa entre que un jugador empieza el juego y termina de la forma más rápida que pueda. Cuando se completa, normalmente se sube un vídeo en un ránking o leaderboard online, donde puede compararse con el resto de tiempos.\n\n\n\nSuper Mario kachaw\n\n\n\n1.1 Tipos de speedruns\nHay diferentes tipos de speedruns. Podríamos dividirlo en 3 grupos:\n\nSingle Segment / RTA\n\nEs el tipo más popular de speedrun. El contador de tiempo no para hasta que el juego es completado y no se puede pausar.\n\nSegmented Speedrun\n\nEs menos popular que el RTA. Este tipo de run permite dividir el videojuego en segmentos, que el jugador puede repetir hasta que los complete en el tiempo deseado. Se busca en concreto la optimización a largo plazo de una run completa.\nComo es más fácil retransmitir en directo segmentos que juegos completos, tuvo una ganancia de popularidad, aunque recientemente se ha reducido debido a la utilización del TAS.\n\nTAS (Tool Assisted Speedrun / Tool Assisted Superplay)\n\nTAS hace referencia a runs específicamente realizadas con un emulador o software concreto. Tienen la habilidad de ir frame por frame y rejugar cualquier segmento todas las veces que se desee. El resultado es el tiempo teórico más rápido en el que un juego puede jugarse.\nPara entenderlo mejor, es como si un ser humano tuviera perfecto tiempo de reacción y suerte. Este tipo de runs también son útiles para descubrir trucos y exploits3 nuevos.\nAl ser un tipo de runs muy diferentes, no se comparan con las de Single Segment o Segmented.\n\n\n1.2 ¿Qué es un frame?\nComo sabemos, un vídeo es una secuencia rápida de imágenes o frames. Si hay pocas imágenes por segundo, el movimiento no es tan fluido. Al incrementar el número de imágenes mostradas por segundo, se reduce esa posbilidad.\nUn frame en este caso es el periodo de tiempo más corto que pasa en un videojuego. Cada frame el juego realiza cálculos, renderiza una imagen en la pantalla y lee instrucciones de los input controllers: mandos, teclados, ratones, joysticks…\nLa velocidad a la que un videojuego actualiza qué se está mostrando se mide en FPS (Frames per Second), a lo que se llama “Frame Rate”. Diferentes videojuegos tienen diferentes frame rates.\nTambién, según tu plataforma, por ejemplo si jugaras en PC, el frame rate depende de tu hardware. En muchos videojuegos donde se realizan speedruns, el frame rate está limitado para realizar ciertos trucos, o para que se produzcan tiempos consistentes y justos.\n\n\n1.3 Categorías\nLas speedruns tienen una gran variedad de categorías, incluso a veces, tienen unas diseñadas para juegos concretos. Aunque existe una gran cantidad, las más comunes son las siguientes:\n\nAny%\n\nHace referencia a que tienes que terminar el videojuego de la manera más rápida posible sin tener en cuenta la progresión de misiones secundarias, coleccionables, enemigos derrotados, etc.\n\n100%\n\nEste tipo de speedruns implica que para terminarlas, tienes que haber completado todo el juego enteramente. Las comunidades de cada juego suelen definir a qué se refieren con “todo”.\n\nLow%\n\nEn estas runs, tienes que realizar la menor cantidad de progreso/logros posible y terminar el videojuego. Algunos juegos tienen un porcentaje de finalización definido, como por ejemplo, terminarlo siendo tu personaje el nivel más bajo posible.\n\nIL (Individual Level)\n\nEn esta categoría, tienes que terminar un único nivel en un videojuego. Al ser más breve que un juego completo, las runs suelen estar muy optimizadas y ser muy competitivas.\nPara terminar y no extenderme más, cabe destacar que existen ciertas normas para realizar speedruns o verificar que los tiempos son correctos, ya que hay personas que han intentado de manera fraudulenta obtener un WR. Por tanto, se toma mucha consideración a la hora de comprobar que una run es válida.\nMencionar también que existen eventos como AGDQ (Awesome Games Done Quick) celebrado en Estados Unidos o el ESA (European Speedrunner Assembly) realizado en Suecia, que son maratones semestrales de speedrun donde hay una recolección de fondos para la caridad y organizaciones benéficas. Son eventos dedicados al entretenimiento y una manera de ver nuevas runs y conocer a jugadores.\nAhora que hemos explorado qué es todo esto del speedrunnning y tenemos una idea general, vamos a observar qué videojuegos son los más populares."
  },
  {
    "objectID": "my_trabajo_BigData.html#videojuegos-más-populares",
    "href": "my_trabajo_BigData.html#videojuegos-más-populares",
    "title": "Videojueguitos rapiditos",
    "section": "2. Videojuegos más populares",
    "text": "2. Videojuegos más populares\nPara comenzar, es interesante analizar cuáles son los videojuegos con más speedruns y por tanto, los más populares.\n\nCódigoGráfico\n\n\n\n\nCódigo\nmost_runs &lt;- speed_games %&gt;% \n  select(Name, Total_Runs) %&gt;% \n  arrange((desc(Total_Runs))) %&gt;% \n  head(., n = 10)\n#- Realizamos el gráfico de barras\n  p1 &lt;- ggplot(most_runs) +\n  geom_bar(aes(x = reorder(Name, Total_Runs), y = Total_Runs, fill = Name), stat = \"identity\", position = \"dodge\", show.legend = FALSE) + \n  geom_text(aes(x = Name, y = Total_Runs, label = Total_Runs), hjust = 1.05, vjust = 0.5, size = 3.5, colour = \"white\")  +\n  labs(title = \"Videojuegos con mayor número de runs\",\n       x = \"Videojuego\",\n       y = \"Runs\",\n       caption = \"Datos provenientes de Kaggle\") + \n  coord_flip() +\n  theme(axis.text.x = element_text(angle = 90, hjust= 1, vjust = 0.5))\n\n\n\n\n\n\nCódigo\np1"
  },
  {
    "objectID": "my_trabajo_BigData.html#videojuegos-y-speedrunning",
    "href": "my_trabajo_BigData.html#videojuegos-y-speedrunning",
    "title": "Análisis general del speedrunning: Super Mario 64",
    "section": "2. Videojuegos y speedrunning",
    "text": "2. Videojuegos y speedrunning\nPara empezar, trataremos de analizar algunos de los rasgos de los videojuegos que históricamente han sido los más populares entre la comunidad de speedrun.\n\n2.1 Los videojuegos más populares\nEn primera instancia, observaremos cuáles son los videojuegos que actualmente son los más populares mediante un gráfico “lollipop”. Consideraremos los más populares los que tienen el mayor número de “runs” registradas hasta el año que nos encontramos, 2024.\nSe contabilizan todas las plataformas, categorías y runs repetidas de los mismos jugadores.\n\nCódigoGráfico\n\n\n\n\nCódigo\np2 &lt;- ggplot(num_runs, aes(x= reorder(Name, Runs), y = Runs)) +\n  geom_point(size = 4.5, colour = \"blue\") + \n  geom_segment( aes(x= Name, xend = Name, y = 0, yend = Runs), color = \"skyblue\", show.legend = FALSE) +\n  geom_text(aes(x = Name, y = Runs, label = Runs), size = 2.7, hjust = 0.5, vjust = 2) +\n  coord_flip() +\n  theme_bw() +\n  labs(title = \"Videojuegos con mayor número de runs\",\n       subtitle = \"Contabilizando todas las plataformas y categorías\",\n       x = \"Videojuego\",\n       y = \"Runs\",\n       caption = \"Datos provenientes de Speedrun.com\")\n\n\n\n\n\n\nCódigo\np2\n\n\n\n\n\n\n\n\n\n\n\n\nEl videojuego con mayor número de runs registradas es el Seterra, un juego de geografía.\nOtra manera de contabilizarlo sería teniendo en cuenta los 3 mejores récords de cada juego, no considerando categorías de sólo 1 nivel o runs obsoletas (es decir, tiempos previos que ya han sido batidos por el mismo jugador). El resultado es muy similar, el cual podríamos ver en el siguiente gráfico de barras.\n\nCódigoGráfico\n\n\n\n\nCódigo\nmost_runs &lt;- speed_games %&gt;% \n  select(Name, Total_Runs) %&gt;% \n  arrange((desc(Total_Runs))) %&gt;% \n  head(., n = 10)\n#- Realizamos el gráfico de barras\n  p1 &lt;- ggplot(most_runs) +\n  geom_bar(aes(x = reorder(Name, Total_Runs), y = Total_Runs, fill = Name), stat = \"identity\", position = \"dodge\", show.legend = FALSE) + \n  geom_text(aes(x = Name, y = Total_Runs, label = Total_Runs), hjust = 1.05, vjust = 0.5, size = 3.5, colour = \"white\")  +\n  labs(title = \"Videojuegos con mayor número de runs\",\n       subtitle = \"Sin contabilizar runs repetidas, teniendo en cuenta los 3 mejores récords\",\n       x = \"Videojuego\",\n       y = \"Runs\",\n       caption = \"Datos provenientes de Kaggle\") + \n  coord_flip() +\n  theme(axis.text.x = element_text(angle = 90, hjust= 1, vjust = 0.5)) +\n  theme_minimal()\n\n\n\n\n\n\nCódigo\np1\n\n\n\n\n\n\n\n\n\n\n\n\nEl número de runs desciende considerablemente, pero los videojuegos más jugados son similares. Esto conlleva a preguntarse, cuál es el mejor videojuego para hacer una speedrun, y de qué géneros son los juegos que escogen los jugadores.\n\n\n2.2 Géneros\nAgrupando los datos para clasificar los videojuegos por género, vamos a explorar cuales serían los más populares a la hora de hacer speedruns, observando todas las runs contabilizadas para cada uno. Se ilustrará mediante un gráfico circular y tomaremos los 5 primeros más jugados.\n\nCódigoGráfico\n\n\n\n\nCódigo\ntop_genres &lt;- speed_games %&gt;%\n  group_by(Genres) %&gt;% \n  summarise(runs = sum(Total_Runs, na.rm = TRUE)) %&gt;% \n  ungroup() %&gt;%\n  arrange((desc(runs))) %&gt;% \n  slice(-c(2)) %&gt;% \n  slice_head(., n = 5)\n#- Realizamos el gráfico\np3 &lt;- ggplot(top_genres, aes(x = \"\", y = runs, fill = reorder(Genres, -runs))) +\n  geom_bar(stat = \"identity\", width = 1, color = \"white\") +\n  coord_polar(theta=\"y\") +\n  geom_text(aes(label = runs), position = position_stack(vjust = 0.5), color = \"black\") +\n  theme_void() + \n  scale_fill_manual(values = c(\"orchid1\", \"olivedrab1\", \"orange2\", \"bisque1\", \"lightblue\"), name = \"Géneros\") +\n  labs(title = \"Géneros más populares\",\n       subtitle = \"En función de las runs realizadas\",\n       caption = \"Datos provenientes de Kaggle\")\n\n\n\n\n\n\nCódigo\np3\n\n\n\n\n\n\n\n\n\n\n\n\nLos juegos de plataformas son los más populares para hacer speedruns. Los 2D junto con los 3D tienen el mayor número de runs registradas, además de que están entre los 10 juegos más populares. Esto puede estar influenciado debido a franquicias como la de Super Mario, que al ser tan conocidas, incentivan que este tipo de géneros estén en lo más alto en cuanto a su popularidad.\nLos siguientes serían los de acción, terror y acción-aventura.\nTambién podrían apreciarse diferencias si se incluyeran los juegos “miscelánea”, categoría que no se ha incluido debido a que usualmente este tipo de juegos tienen un objetivo concreto y no el de completar el juego enteramente, por lo que no suelen ser tan representativos.\nSorprende que en este ránking no aparezcan videojuegos de carreras, ya que podría correlacionarse el objetivo de estos con hacer una speedrun: acabar lo antes posible. Es probable que la tendencia de estos juegos no sea el no tener como concepto completarlo entero, si no ciertas carreras o misiones, lo que no podríamos considerar como una run entera en la selección de los datos.\nEn general, los jugadores suelen recomendar títulos clásicos ya que suelen tener una duración más corta para comenzar en el mundo del speedrunning.\nVamos a centrarnos en uno de los juegos más importantes, Super Mario 64."
  },
  {
    "objectID": "my_trabajo_BigData.html#footnotes",
    "href": "my_trabajo_BigData.html#footnotes",
    "title": "Análisis general del speedrunning: Super Mario 64",
    "section": "Notas",
    "text": "Notas\n\n\nUn bug se refiere a cuando un software actúa de una manera que los programadores no pretendían debido a problemas en la programación. Aquí lo explican.↩︎\nUn glitch es un término usado en videojuegos donde un tipo de error hace que cualquier modelo o textura no carguen debidamente. Aquí se explica y diferencia de los bugs.↩︎\nUn exploit en videojuegos es el uso de un bug, gitch, o cualquier elemento de un sistema de juego que no funciona como prentedían los desarrolladores, que otorga una ventaja injusta a los jugadores. En Wikipedia lo explican.↩︎"
  },
  {
    "objectID": "my_trabajo_BigData.html#super-mario-64",
    "href": "my_trabajo_BigData.html#super-mario-64",
    "title": "Análisis general del speedrunning: Super Mario 64",
    "section": "3. Super Mario 64",
    "text": "3. Super Mario 64\n\n\n\nSuper Mario super simpático\n\n\nSuper Mario 64 es un videojuego del género de plataformas desarrollado y publicado por Nintendo para la Nintendo 64. Se estrenó en Japón y Norte América en 1996, y en el resto de regiones en el año 1997.\nEs el primer juego de Super Mario que tenía una nueva característica: jugabilidad en 3D, combinando el estilo de arte típico, gameplay y personajes tradicionales en mundo abierto, con un sistema de cámara dinámica y control analógico de 360 grados.\nTiene una gran popularidad, además de que es considerado uno de los mejores juegos de todos los tiempos. Ha resultado ser una influencia muy importante para los juegos del mismo género posteriores (Plataformas 3D). En 2004 fue relanzado para la Nintendo DS, y desde entonces ha sido trasladado a otras consolas de Nintendo.\nEn el juego controlas a Mario a través de varios escenarios. Bowser, el antagonista principal, invade el castillo de la Princesa Peach, escondiendo estrellas por diferentes mundos. El jugador reúne estas estrellas para poder entrar al castillo y rescatar a Peach.\n\n3.1 Speedruns de Super Mario 64\nEn Super Mario 64 existen diferentes categorías de speedrun. Como se ha mencionado en el punto 1.3, en este caso, hay categorías para el propio juego. Las más comunes son relacionadas con la cantidad de estrellas que Mario tiene que conseguir para completar el juego: 120 estrellas, 70 estrellas, 16 estrellas, 1 estrella y 0.\nEn teoría, para terminar el juego, tienes que obtener 120 estrellas repartidas por los diferentes escenarios. Los desarrolladores también programaron que puedas recoger un mínimo de 70 y que aún así puedas terminarlo.\nCuando se empezaron a hacer speedruns, el número de estrellas requeridas para ganar fue descendiendo cada vez más, a 50, 31 y por último, en el año 2004, el número cayó a 16, pudiéndose completar el juego en menos de media hora, cuando la duración del juego para un jugador promedio está fijada en 13 horas, y para completarlo entero en las 20 horas. Esto es debido a los trucos que encontraban los jugadores para ir acortando el tiempo y los requisitos para completar el juego.\nVamos a observar cuáles son las categorías más populares en función de las runs realizadas.\n\n\n3.2 Categorías de Super Mario 64 más populares\nEn el siguiente gráfico de puntos, analizaremos cuál es la categoría más jugada de Super Mario 64.\n\nCódigoGráfico\n\n\n\n\nCódigo\ncat_mario &lt;- speed_cat %&gt;% \n  filter(Game_Id == \"0\") %&gt;% \n  group_by(Category) %&gt;% \n  summarise(runs = sum(Num_Runs, na.rm = TRUE)) %&gt;% \n  ungroup() %&gt;%\n  arrange((desc(runs)))\n#- Realizamos el gráfico\ncat_mario_order &lt;- cat_mario[c(5, 4, 1, 2, 3),]\np4 &lt;- ggplot(cat_mario_order, aes(x = Category, y = runs, color = Category)) +\n    geom_point(size = 13, shape = \"\\u2605\", show.legend = FALSE, alpha = 0.7) +\n    geom_text(aes(label = runs), hjust = -0.7, vjust = 0.5, color = \"ivory4\") +\n    theme_minimal() +\n    labs(\n    title = \"Categorías de Super Mario 64\",\n       subtitle = \"Según el número de runs\",\n       caption = \"Fuente: Speedrun.com\",\n       x = \"Categorías\",\n       y = \"Número runs\")\n\n\n\n\n\n\nCódigo\np4\n\n\n\n\n\n\n\n\n\n\n\n\nPor lo que podemos ver, la categoría de 16 estrellas es una de las categorías más populares con mayor número de speedruns registradas.\nTener un récord mundial en esta categoría es uno de los logros más difíciles, debido a la complejidad de los “trucos” que se usan para bajar el cronómetro, así como mantenerlo por su alta competitividad.\nAl ser la categoría de 16 estrellas la más popular, vamos a centrar aún más nuestro análisis, y vamos a proceder a observar los récords registrados para esta categoría concreta.\n\n\n3.3 Récords de la categoría de 16 estrellas\nAntes de observar algunos datos sobre los récords de tiempo, quiero recomendar el canal de Youtube de Summoning Salt, el cual tiene vídeos muy interesantes sobre la historia del speedrun.\nRelacionado con este tema en concreto, el siguiente vídeo trata de cómo ha ido evolucionando el récord de tiempo de 16 estrellas del Super Mario 64, explicando con detenimiento los trucos descubiertos y utilizados por diferentes jugadores, así como su lucha competitiva por conseguir el primer puesto.\n\nPara ilustrarlo, vamos a observar en un gráfico los cambios en la reducción del tiempo récord por diversos jugadores a medida del paso del tiempo de esta categoría. Tomaremos una muestra de 50 récords.\n\nCódigoGráfico\n\n\n\n\nCódigo\n#- Creamos una función para formatear los tiempos de las runs\nformatRunTime &lt;- function(time){\n  time_formatted = str_replace_all(time, c(\"ms\"=\"\",\"m\"=\":\",\"s \"=\".\",\"s\"=\"\",\" \"=\"\")) %&gt;%\n  as.POSIXct(format=\"%M:%OS\")\n}\n\n#- Ordenamos y arreglamos los datos\nrec_Alltime &lt;- mario_record %&gt;%\n  select(Date, Players, Time) %&gt;%\n  mutate(Date = as.Date(Date, format = \"%Y-%m-%d\")) %&gt;% \n  mutate(Time_formatted = formatRunTime(Time))\n\n#- Gráfico\np6 &lt;- ggplot(rec_Alltime, aes(x = Date, y = Time_formatted, color = Players)) +\n  geom_segment(aes(color = Players, group = 1, xend = lead(Date), yend = lead(Time_formatted))) +\n  geom_point() +\n  scale_y_datetime(date_breaks = \"1 min\", date_labels = \"00:%M:%S\") +\n  labs(title = \"Evolución de los Récords de Mario 64. Categoría 16 estrellas.\",\n       x = \"Año\",\n       y = \"Tiempo\") +\n  theme_minimal()\n\n\n\n\n\n\nCódigo\nggplotly(p6)\n\n\n\n\n\n\n\n\n\nEl gráfico muestra una tendencia negativa, donde el tiempo para terminar el juego es cada vez menor.\nEl primer récord notable fue en noviembre de 2004, donde un jugador llamado Illudude, terminó el juego recogiendo 16 estrellas en 21 minutos y 56 segundos.\n6 meses después, el jugador kirbykarter bajó el tiempo en 1 minuto y 9 segundos, siendo su récord de 20 minutos y 46 segundos.\nMás tarde se provocó una lucha competitiva entre los jugadores Shigeru y taka12352, ambos japoneses, que iban quitándose el uno al otro el récord, llegando Shigeru a alcanzar un tiempo de 16 minutos y 6 segundos en el año 2011.\nEn el año 2015 - 2016, los jugadores Akira y Xiah, también japoneses, tuvieros una disputa parecida, terminando Xiah con un tiempo de 15 minutos y 24 segundos en 2016.\nA partir de 2018, jugadores como Weege, akki, Dowsky, Slipperynip, KANNO y Suigi estuvieron repartiéndose el récord, hasta llegar al año 2021, donde Suigi lo ha seguido manteniendo y mejorando. Actualmente es el jugador que lidera la clasificación, con un tiempo de 14 minutos y 35 segundos, conseguido en marzo de 2023.\nEn el gráfico podemos observar como estos trucos o bugs descubiertos por los jugadores, con el paso de los años, han reportado cada vez menos reducciones del contador de tiempo. Es por ello, que podríamos compararlo en economía, con la ley de rendimientos decrecientes, que a grandes rasgos hace referencia a cuando el aumento de producción es menor con cada nueva incorporación de factores. También se podría comparar con innovaciones tecnológicas, donde cada vez se tarda más tiempo en aplicar una y es más difícil obtener una ganancia mayor. En el speedrun ocurre lo mismo: los primeros descubrimientos provocan grandes reducciones del récord, hasta que la run es optimizada al máximo y es más difícil reportar un gran recorte.\n\n\n3.4 Tabla de clasificación actual\nAhora mismo, esta es la clasificación actual ordenada en función del mejor récord registrado (el tiempo más bajo en segundos). Como es una clasificación con un gran número de jugadores, mostramos los 15 primeros.\n\nCódigoTabla\n\n\n\n\nCódigo\n#- Estos datos están prácticamente limpios, así que seleccionamos lo que nos interesa para realizar la tabla\ntab_record &lt;- mario_16 %&gt;% \n  select(player_name, real_time_seconds) %&gt;% \n  slice_head(., n = 15)\n\ncolnames(tab_record) &lt;- c(\"Jugadores\", \"Tiempo en segundos\")\n#- Realizamos la tabla\np5 &lt;- tab_record %&gt;% \n  gt() %&gt;% \n  gt_theme_dot_matrix() %&gt;% \n  tab_header(title = md(\"Récords de *speedruns* de Super Mario 64\"),\n             subtitle = md(\"En la categoría de `16 estrellas`\")) %&gt;% \n  tab_footnote(\n    footnote = \"Fuente: Speedrun.com\")\n\n\n\n\n\n\nCódigo\np5\n\n\n\n\n\n\n  \n    \n      Récords de speedruns de Super Mario 64\n    \n    \n      En la categoría de 16 estrellas\n    \n    \n      Jugadores\n      Tiempo en segundos\n    \n  \n  \n    Suigi\n875.50\n    Slipperynip\n881.21\n    Weegee\n885.21\n    Finnii602\n892.00\n    Dowsky\n895.81\n    GTM\n895.90\n    KANNO\n896.22\n    Tag609\n896.33\n    gamiru\n897.46\n    Raisn\n898.00\n    Zapy\n898.10\n    akki\n899.33\n    treybordo\n900.24\n    Thomkar\n904.73\n    cjrokokomero\n906.73\n  \n  \n  \n    \n       Fuente: Speedrun.com\n    \n  \n\n\n\n\n\n\n\nAl mirar la tabla, parece que a primera vista no hay tanta diferencia entre los primeros puestos en segundos. El récord mundial y el segundo puesto están separados por 6 segundos de diferencia. Pero, si tenemos en cuenta el contexto de este juego, el cual ha llegado al punto de estar muy optimizado, es decir, que los incrementos de ventaja gracias a nuevos descubrimientos han ido reduciéndose, podría considerarse una gran diferencia. Muchas veces, también influyen causas externas, como la suerte del jugador, cuántos intentos le lleva conseguir el truco… ya que hay muchas cosas que pueden salir mal en una run.\nEl siguiente vídeo documenta el récord mundial actual (WR) del jugador Suigi, que, desde hace 10 meses, ostenta el récord de la categoría con un tiempo de 14 minutos y 35 segundos.\n\n\n\n3.5 Nacionalidad de los jugadores\nPor último y como curiosidad, se representará en un mapa la nacionalidad de los jugadores para así determinar qué países tienen más récords en la categoría de 16 estrellas y observar cómo están repartidos. 47 es el número de países que han registrado un récord al menos una vez.\n\nCódigoMapa\n\n\n\n\nCódigo\nmap_data &lt;- mario_16 %&gt;% \n  group_by(player_country) %&gt;%\n  summarise(records = n()) %&gt;% \n  slice(-c(1)) %&gt;% \n  arrange((desc(records)))\n\n#- Realizamos el map-plot\ndata(World)\nworld &lt;- World\nworld &lt;- World %&gt;%\n  filter(name != \"Antarctica\") %&gt;%\n  select(name, geometry)\nrm(World)\n\n# Nombre de columnas consistente para el JOIN\nmap_data &lt;- map_data %&gt;% rename(name = player_country)\n\n# Join\nrecords_map_data &lt;- left_join(world, map_data, by = \"name\")\n\n# Map\np7 &lt;- tm_shape(records_map_data) +\n  tm_borders() +\n  tm_fill(col = \"records\", style = \"jenks\", palette = \"Blues\", title = \"Número de récords\") +\n  tm_text(\"records\", size = 0.5, root = 4, col = \"black\") +\n  tm_layout(\n    main.title = \"Récords de Super Mario 64 según países\", \n    main.title.position = \"center\",\n    legend.format = list(fun = function(x) formatC(x, format = \"d\")))\n\n\n\n\n\n\nCódigo\np7\n\n\n\n\n\n\n\n\n\n\n\n\nEl país con más récords en esta categoría sería Estados Unidos, con 185 récords, seguido de Japón, con 52. Alemania, Canadá, Francia y Australia son los siguientes y comprenden números muy similares. En el puesto número 10 estaría España, con 9 récords.\nPor tanto, este juego y categoría de 16 estrellas está dominada por jugadores estadounidenses."
  },
  {
    "objectID": "my_trabajo_BigData.html#récords-de-la-categoría-de-16-estrellas",
    "href": "my_trabajo_BigData.html#récords-de-la-categoría-de-16-estrellas",
    "title": "Análisis general del speedrunning: Super Mario 64",
    "section": "3.3 Récords de la categoría de 16 estrellas",
    "text": "3.3 Récords de la categoría de 16 estrellas\nAntes de observar algunos datos sobre los récords de tiempo, quiero recomendar el canal de Youtube de Summoning Salt, el cual tiene vídeos muy interesantes sobre la historia del speedrun.\nRelacionado con este tema en concreto, el siguiente vídeo trata de cómo ha ido evolucionando el récord de tiempo de 16 estrellas del Super Mario 64, explicando con detenimiento los trucos descubiertos y utilizados por diferentes jugadores, así como su lucha competitiva por conseguir el primer puesto.\n\nPara ilustrarlo, vamos a observar en un gráfico los cambios en la reducción del tiempo récord por diversos jugadores a medida del paso del tiempo de esta categoría. Tomaremos una muestra de 50 récords.\n\nCódigoGráfico\n\n\n\n\n\n\n\n\n\nEl primer récord notable fue en noviembre de 2004, donde un jugador llamado Illudude, terminó el juego recogiendo 16 estrellas en 21 minutos y 56 segundos."
  },
  {
    "objectID": "my_trabajo_BigData.html#tabla-de-récords-actual-de-clasificaciones",
    "href": "my_trabajo_BigData.html#tabla-de-récords-actual-de-clasificaciones",
    "title": "Análisis general del speedrunning: Super Mario 64",
    "section": "3.4 Tabla de récords actual de clasificaciones",
    "text": "3.4 Tabla de récords actual de clasificaciones\nAhora mismo,\n\n\nCódigo\n#- segundo gráfico\n\n\nVídeo que documenta el récord actual del jugador laputisimavida"
  },
  {
    "objectID": "my_trabajo_BigData.html#nacionalidad-de-los-jugadores",
    "href": "my_trabajo_BigData.html#nacionalidad-de-los-jugadores",
    "title": "Análisis general del speedrunning: Super Mario 64",
    "section": "3.5 Nacionalidad de los jugadores",
    "text": "3.5 Nacionalidad de los jugadores\n\n\nCódigo\n#- tercer gráfico"
  },
  {
    "objectID": "my_trabajo_BigData.html#conclusiones",
    "href": "my_trabajo_BigData.html#conclusiones",
    "title": "Análisis general del speedrunning: Super Mario 64",
    "section": "Conclusiones",
    "text": "Conclusiones\nComo conclusión de todo lo analizado, podemos determinar que el speedrunning es una forma diferente, competitiva y amena de completar un videojuego.\nLos géneros preferidos por los jugadores para hacer speedruns son los videojuegos de plataforma, lo que probablemente esté influenciado a que grandes franquicias, como la de Super Mario, hayan impulsado su popularidad. También se recomiendan títulos clásicos y más cortos.\nObservando uno de los juegos más populares con un gran número de runs registradas, además de los más importantes e influyentes en el género de plataformas 3D, Super Mario 64, hemos podido comprobar como su categoría más popular para realizar speedruns es la de 16 estrellas.\nTambién hemos podido observar en cuanto a los récords, que podrían ser similares a un proceso de innovación en economía o al término rendimientos decrecientes, ya que al principio en el año 2004, cada truco descubierto procuraba una ganancia de tiempo muy amplia, y a largo plazo, estas ventajas se han ido reduciendo, hasta que se puede observar con los datos más recientes como el récord sólo mejora unos segundos, denotando que la run está muy optimizada. Esta situación puede cambiar gracias a la tecnología con runs tipo TAS, softwares los cuales encuentran formas de acortar el tiempo que a un ser humano le resultaría difícil encontrar practicando una run de manera habitual.\nPor último hemos echazo un vistazo a cómo en la categoría de 16 estrellas, los récords están liderados por Estados Unidos y Japón.\nEl speedrunning es un tema bastante amplio e interesante, donde se pueden establecer ideas relacionadas con el machine learning y crear modelos. Aunque el trabajo es desde una perspectiva general para que personas que quizá no conozcan el tema puedan interesarse o reparar en algo nuevo, es necesario apuntar que se puede analizar con mucha mayor profundidad y relacionar con otros muchos otros aspectos."
  },
  {
    "objectID": "my_trabajo_BigData.html#referencias",
    "href": "my_trabajo_BigData.html#referencias",
    "title": "Análisis general del speedrunning: Super Mario 64",
    "section": "Referencias",
    "text": "Referencias\n\nSpeedrun.com: Stats de Super Mario 64\nKaggle: Super Mario 64 Speedruns\nReddit: Subreddit de speedruns\nCanal de Summoning Salt\nNoticia History Computer: Cheese, jugador madrileño que logró un récord en la categoría de 120 estrellas\n\n\n\n\nInformación sobre la sesión\nAbajo muestro mi entorno de trabajo y paquetes utilizados.\n\n\n\n\n current session info \n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16 ucrt)\n os       Windows 11 x64 (build 22631)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  Spanish_Spain.utf8\n ctype    Spanish_Spain.utf8\n tz       Europe/Madrid\n date     2024-01-24\n pandoc   3.1.1 @ D:/Programming_2023/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package       * version   date (UTC) lib source\n abind           1.4-5     2016-07-21 [1] CRAN (R 4.3.1)\n base64enc       0.1-3     2015-07-28 [1] CRAN (R 4.3.0)\n cellranger      1.1.0     2016-07-27 [1] CRAN (R 4.3.1)\n class           7.3-22    2023-05-03 [1] CRAN (R 4.3.1)\n classInt        0.4-10    2023-09-05 [1] CRAN (R 4.3.1)\n cli             3.6.1     2023-03-23 [1] CRAN (R 4.3.1)\n clipr           0.8.0     2022-02-22 [1] CRAN (R 4.3.1)\n codetools       0.2-19    2023-02-01 [1] CRAN (R 4.3.1)\n colorspace      2.1-0     2023-01-23 [1] CRAN (R 4.3.1)\n commonmark      1.9.0     2023-03-17 [1] CRAN (R 4.3.1)\n crosstalk       1.2.0     2021-11-04 [1] CRAN (R 4.3.1)\n data.table      1.14.8    2023-02-17 [1] CRAN (R 4.3.1)\n DBI             1.1.3     2022-06-18 [1] CRAN (R 4.3.1)\n desc            1.4.3     2023-12-10 [1] CRAN (R 4.3.2)\n details         0.3.0     2022-03-27 [1] CRAN (R 4.3.2)\n dichromat       2.0-0.1   2022-05-02 [1] CRAN (R 4.3.1)\n digest          0.6.33    2023-07-07 [1] CRAN (R 4.3.1)\n dplyr         * 1.1.3     2023-09-03 [1] CRAN (R 4.3.1)\n e1071           1.7-13    2023-02-01 [1] CRAN (R 4.3.1)\n ellipsis        0.3.2     2021-04-29 [1] CRAN (R 4.3.1)\n evaluate        0.21      2023-05-05 [1] CRAN (R 4.3.1)\n fansi           1.0.4     2023-01-22 [1] CRAN (R 4.3.1)\n farver          2.1.1     2022-07-06 [1] CRAN (R 4.3.1)\n fastmap         1.1.1     2023-02-24 [1] CRAN (R 4.3.1)\n fontawesome     0.5.2     2023-08-19 [1] CRAN (R 4.3.1)\n forcats       * 1.0.0     2023-01-29 [1] CRAN (R 4.3.1)\n formatR         1.14      2023-01-17 [1] CRAN (R 4.3.1)\n generics        0.1.3     2022-07-05 [1] CRAN (R 4.3.1)\n ggplot2       * 3.4.3     2023-08-14 [1] CRAN (R 4.3.1)\n ggThemeAssist * 0.1.5     2016-08-13 [1] CRAN (R 4.3.1)\n ggthemes      * 4.2.4     2021-01-20 [1] CRAN (R 4.3.1)\n glue            1.6.2     2022-02-24 [1] CRAN (R 4.3.1)\n gridExtra       2.3       2017-09-09 [1] CRAN (R 4.3.1)\n gt            * 0.9.0     2023-03-31 [1] CRAN (R 4.3.1)\n gtable          0.3.4     2023-08-21 [1] CRAN (R 4.3.1)\n gtExtras      * 0.5.0     2023-09-15 [1] CRAN (R 4.3.2)\n hms             1.1.3     2023-03-21 [1] CRAN (R 4.3.1)\n htmltools       0.5.6     2023-08-10 [1] CRAN (R 4.3.1)\n htmlwidgets     1.6.2     2023-03-17 [1] CRAN (R 4.3.1)\n httpuv          1.6.11    2023-05-11 [1] CRAN (R 4.3.1)\n httr            1.4.7     2023-08-15 [1] CRAN (R 4.3.1)\n jsonlite        1.8.7     2023-06-29 [1] CRAN (R 4.3.1)\n KernSmooth      2.23-21   2023-05-03 [1] CRAN (R 4.3.1)\n knitr           1.44      2023-09-11 [1] CRAN (R 4.3.1)\n labeling        0.4.3     2023-08-29 [1] CRAN (R 4.3.1)\n later           1.3.1     2023-05-02 [1] CRAN (R 4.3.1)\n lattice         0.21-8    2023-04-05 [1] CRAN (R 4.3.1)\n lazyeval        0.2.2     2019-03-15 [1] CRAN (R 4.3.1)\n leafem          0.2.3     2023-09-17 [1] CRAN (R 4.3.2)\n leaflet         2.2.1     2023-11-13 [1] CRAN (R 4.3.2)\n leafsync        0.1.0     2019-03-05 [1] CRAN (R 4.3.2)\n lifecycle       1.0.3     2022-10-07 [1] CRAN (R 4.3.1)\n lubridate     * 1.9.2     2023-02-10 [1] CRAN (R 4.3.1)\n lwgeom          0.2-13    2023-05-22 [1] CRAN (R 4.3.2)\n magrittr        2.0.3     2022-03-30 [1] CRAN (R 4.3.1)\n maps          * 3.4.1.1   2023-11-03 [1] CRAN (R 4.3.2)\n markdown        1.8       2023-08-23 [1] CRAN (R 4.3.1)\n mime            0.12      2021-09-28 [1] CRAN (R 4.3.0)\n miniUI          0.1.1.1   2018-05-18 [1] CRAN (R 4.3.1)\n munsell         0.5.0     2018-06-12 [1] CRAN (R 4.3.1)\n paletteer       1.5.0     2022-10-19 [1] CRAN (R 4.3.1)\n pillar          1.9.0     2023-03-22 [1] CRAN (R 4.3.1)\n pkgconfig       2.0.3     2019-09-22 [1] CRAN (R 4.3.1)\n plotly        * 4.10.2    2023-06-03 [1] CRAN (R 4.3.1)\n png             0.1-8     2022-11-29 [1] CRAN (R 4.3.0)\n promises        1.2.1     2023-08-10 [1] CRAN (R 4.3.1)\n proxy           0.4-27    2022-06-09 [1] CRAN (R 4.3.1)\n purrr         * 1.0.2     2023-08-10 [1] CRAN (R 4.3.1)\n R6              2.5.1     2021-08-19 [1] CRAN (R 4.3.1)\n raster          3.6-26    2023-10-14 [1] CRAN (R 4.3.2)\n RColorBrewer    1.1-3     2022-04-03 [1] CRAN (R 4.3.0)\n Rcpp            1.0.11    2023-07-06 [1] CRAN (R 4.3.1)\n readr         * 2.1.4     2023-02-10 [1] CRAN (R 4.3.1)\n readxl        * 1.4.3     2023-07-06 [1] CRAN (R 4.3.1)\n rematch2        2.1.2     2020-05-01 [1] CRAN (R 4.3.1)\n rlang           1.1.1     2023-04-28 [1] CRAN (R 4.3.1)\n rmarkdown       2.25      2023-09-18 [1] CRAN (R 4.3.1)\n rstudioapi      0.15.0    2023-07-07 [1] CRAN (R 4.3.1)\n s2              1.1.4     2023-05-17 [1] CRAN (R 4.3.2)\n sass            0.4.7     2023-07-15 [1] CRAN (R 4.3.1)\n scales          1.2.1     2022-08-20 [1] CRAN (R 4.3.1)\n sessioninfo     1.2.2     2021-12-06 [1] CRAN (R 4.3.2)\n sf            * 1.0-14    2023-07-11 [1] CRAN (R 4.3.2)\n shiny           1.7.5     2023-08-12 [1] CRAN (R 4.3.1)\n sp              2.1-1     2023-10-16 [1] CRAN (R 4.3.2)\n stars           0.6-4     2023-09-11 [1] CRAN (R 4.3.2)\n stringi         1.7.12    2023-01-11 [1] CRAN (R 4.3.0)\n stringr       * 1.5.0     2022-12-02 [1] CRAN (R 4.3.1)\n terra           1.7-55    2023-10-13 [1] CRAN (R 4.3.2)\n tibble        * 3.2.1     2023-03-20 [1] CRAN (R 4.3.1)\n tidyr         * 1.3.0     2023-01-24 [1] CRAN (R 4.3.1)\n tidyselect      1.2.0     2022-10-10 [1] CRAN (R 4.3.1)\n tidyverse     * 2.0.0     2023-02-22 [1] CRAN (R 4.3.1)\n timechange      0.2.0     2023-01-11 [1] CRAN (R 4.3.1)\n tmap          * 3.3-4     2023-09-12 [1] CRAN (R 4.3.2)\n tmaptools       3.1-1     2021-01-19 [1] CRAN (R 4.3.2)\n tzdb            0.4.0     2023-05-12 [1] CRAN (R 4.3.1)\n units           0.8-4     2023-09-13 [1] CRAN (R 4.3.2)\n utf8            1.2.3     2023-01-31 [1] CRAN (R 4.3.1)\n vctrs           0.6.3     2023-06-14 [1] CRAN (R 4.3.1)\n viridis       * 0.6.4     2023-07-22 [1] CRAN (R 4.3.2)\n viridisLite   * 0.4.2     2023-05-02 [1] CRAN (R 4.3.1)\n withr           2.5.0     2022-03-03 [1] CRAN (R 4.3.1)\n wk              0.9.0     2023-10-22 [1] CRAN (R 4.3.2)\n xfun            0.40      2023-08-09 [1] CRAN (R 4.3.1)\n XML             3.99-0.16 2023-11-29 [1] CRAN (R 4.3.2)\n xml2            1.3.5     2023-07-06 [1] CRAN (R 4.3.1)\n xtable          1.8-4     2019-04-21 [1] CRAN (R 4.3.1)\n yaml            2.3.7     2023-01-23 [1] CRAN (R 4.3.0)\n\n [1] D:/Programming_2023/R-4.3.1/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "my_trabajo_BigData.html#tabla-de-clasificación-de-récords-actuales",
    "href": "my_trabajo_BigData.html#tabla-de-clasificación-de-récords-actuales",
    "title": "Análisis general del speedrunning: Super Mario 64",
    "section": "3.4 Tabla de clasificación de récords actuales",
    "text": "3.4 Tabla de clasificación de récords actuales\nAhora mismo, esta es la tabla actual ordenada por el mejor récord (el tiempo más bajo) registrado. Mostramos los 15 primeros.\n\nCódigoGráfico\n\n\n\n\nCódigo\n#- segundo gráfico\n\n\n\n\n\n\n\n\nEl siguiente vídeo documenta el récord mundial actual (WR) del jugador Suigi, que como hemos podido observar, desde hace 10 meses ostenta el récord de la categoría con un tiempo de 14 minutos y 35 segundos.\n\n\n3.5 Nacionalidad de los jugadores\n\n\nCódigo\n#- tercer gráfico"
  }
]